# M3-06 TypeORM II

[Volver a Inicio](../README.md)

## Links

[EntityManager API - TypeORM](https://typeorm.io/entity-manager-api)

[Repository APIs - TypeORM](https://typeorm.io/repository-api)

[Query Builder - TypeORM](https://typeorm.io/select-query-builder)

## Transacciones

Todas las operaciones en una transacci贸n se completan correctamente o ninguna de ellas se aplica, asegurando la consistencia de los datos.
**Caracter铆sticas de las Transacciones**:

1. **Atomicidad**: Todas las operaciones dentro de la transacci贸n se consideran como una 煤nica unidad de trabajo. Si alguna operaci贸n falla, todas las operaciones se revierten.
2. **Consistencia**: La base de datos pasa de un estado consistente a otro estado consistente despu茅s de la transacci贸n.
3. **Aislamiento**: Las operaciones dentro de una transacci贸n son aisladas de las operaciones en otras transacciones.
4. **Durabilidad**: Una vez que una transacci贸n se ha confirmado (commit), los cambios se guardan permanentemente en la base de datos.

### Niveles de Aislamiento de Transacciones

El nivel de aislamiento es un concepto clave en el manejo de transacciones en bases de datos. Define la forma en que las transacciones se comportan respecto a la visibilidad de los cambios realizadas por otras transacciones concurrentes. Los niveles de aislamiento son importantes porque pueden afectar tanto el rendimiento como la consistencia de los datos en un sistema de base de datos.

Existen cuatro niveles de aislamiento est谩ndar, definidos por el SQL est谩ndar y soportados por la mayor铆a de los sistemas de gesti贸n de bases de datos (DBMS).

1. Read Uncommitted (Lectura No Confirmada)
   - **Descripci贸n**: Las transacciones pueden leer datos que han sido modificados pero no confirmados (committed) por otras transacciones.
   - **Ventajas**: Mayor rendimiento debido a menor cantidad de bloqueos.
   - **Desventajas**: Posibilidad de lecturas sucias (dirty reads), donde una transacci贸n puede ver datos no confirmados de otra transacci贸n que podr铆a ser revertida posteriormente.
   - **Problemas**:
     - **Dirty Reads**: Lectura de datos no confirmados.
     - **Non-Repeatable Reads**: Un valor le铆do puede cambiar si otra transacci贸n lo modifica y confirma.
     - **Phantom Reads**: Nuevas filas pueden aparecer si otra transacci贸n las inserta y confirma.
2. Read Committed (Lectura Confirmada)
   - **Descripci贸n**: Las transacciones solo pueden leer datos que han sido confirmados por otras transacciones. Cada lectura dentro de una transacci贸n puede ver cambios confirmados por otras transacciones.
   - **Ventajas**: Evita lecturas sucias.
   - **Desventajas**: A煤n permite lecturas no repetibles.
   - **Problemas**:
     - **Non-Repeatable Reads**: Un valor le铆do puede cambiar si otra transacci贸n lo modifica y confirma.
     - **Phantom Reads**: Nuevas filas pueden aparecer si otra transacci贸n las inserta y confirma.
3. Repeatable Read (Lectura Repetible)
   - **Descripci贸n**: Las transacciones garantizan que si leen un valor, ninguna otra transacci贸n puede modificar ese valor hasta que la transacci贸n inicial sea confirmada o revertida. Sin embargo, otras transacciones pueden insertar nuevas filas que no ser谩n vistas hasta que la transacci贸n actual finalice.
   - **Ventajas**: Evita lecturas sucias y lecturas no repetibles.
   - **Desventajas**: Mayor uso de bloqueos, lo que puede afectar el rendimiento.
   - **Problemas**:
     - **Phantom Reads**: Nuevas filas pueden aparecer si otra transacci贸n las inserta y confirma.
4. Serializable (Serializable)
   - **Descripci贸n**: El nivel de aislamiento m谩s estricto. Las transacciones se ejecutan de manera que parece que fueron ejecutadas secuencialmente, una tras otra, en lugar de concurrentemente. Evita todas las posibles anomal铆as de concurrencia.
   - **Ventajas**: M谩xima consistencia de datos.
   - **Desventajas**: Peor rendimiento debido a la mayor cantidad de bloqueos y a la necesidad de manejar conflictos.
   - **Problemas**: Ninguna de las anomal铆as descritas es posible en este nivel.

#### Problemas de Concurrencia

1. Dirty Reads (Lecturas Sucias): Ocurren cuando una transacci贸n lee datos que han sido modificados por otra transacci贸n que a煤n no se ha confirmado. Si la transacci贸n que hizo los cambios se revierte, la transacci贸n que ley贸 los datos ver谩 informaci贸n incorrecta.
2. Non-Repeatable Reads (Lecturas No Repetibles): Suceden cuando una transacci贸n lee el mismo dato m谩s de una vez y obtiene diferentes valores cada vez debido a que otra transacci贸n ha modificado y confirmado los datos entre las lecturas.
3. Phantom Reads (Lecturas Fantasma): Se producen cuando una transacci贸n obtiene diferentes resultados al ejecutar la misma consulta varias veces, porque otra transacci贸n ha insertado, modificado o eliminado filas que coinciden con la condici贸n de la consulta.

## Repositorios

### Flow del HTTP Request

<img src="./assets/06-01.png" alt="http request"/>

### AppDataSource.manager Vs Repository

```ts
// Utilizando "AppDataSource.manager" => TODOS LOS REPOSITORIOS:
const videogames = await AppDataSource.manager.find(Videogame);

// Utilizando un "Repositorio":
const videogameRepository = AppDataSource.getRepository(Videogame);
const videogames = await videogameRepository.find();
```

## Subscribers y Entity Listeners

### 1. Subscribers

- Un **Subscriber** en TypeORM es una clase que escucha a ciertos eventos de la base de datos y ejecuta acciones espec铆ficas cuando esos eventos ocurren.
- Los subscribers se utilizan para agregar l贸gica personalizada que se ejecuta autom谩ticamente en respuesta a eventos como la inserci贸n, actualizaci贸n, eliminaci贸n y carga de entidades.

#### ★Tipos de Eventos en TypeORM

Los subscribers pueden escuchar los siguientes tipos de eventos:

- `beforeInsert`: Se ejecuta antes de que una entidad se inserte en la base de datos.
- `afterInsert`: Se ejecuta despu茅s de que una entidad se haya insertado en la base de datos.
- `beforeUpdate`: Se ejecuta antes de que una entidad se actualice en la base de datos.
- `afterUpdate`: Se ejecuta despu茅s de que una entidad se haya actualizado en la base de datos.
- `beforeRemove`: Se ejecuta antes de que una entidad se elimine de la base de datos.
- `afterRemove`: Se ejecuta despu茅s de que una entidad se haya eliminado de la base de datos.
- `beforeSoftRemove`: Se ejecuta antes de que una entidad se elimine de forma suave.
- `afterSoftRemove`: Se ejecuta despu茅s de que una entidad se haya eliminado de forma suave.
- `beforeRecover`: Se ejecuta antes de que una entidad se recupere de una eliminaci贸n suave.
- `afterRecover`: Se ejecuta despu茅s de que una entidad se haya recuperado de una eliminaci贸n suave.
- `afterLoad`: Se ejecuta despu茅s de que una entidad se haya cargado desde la base de datos.

### 2. Entity Listeners

- Son m茅todos dentro de las clases de entidad que se ejecutan en respuesta a eventos espec铆ficos del ciclo de vida de la entidad, como antes o despu茅s de insertar, actualizar o eliminar registros.
- Estos listeners permiten ejecutar l贸gica personalizada en momentos clave del ciclo de vida de la entidad.

#### ★Eventos de Ciclo de Vida

Los eventos de ciclo de vida que se pueden capturar con entity listeners en TypeORM incluyen:

- `@BeforeInsert`: Se ejecuta antes de que una nueva entidad sea insertada en la base de datos.
- `@AfterInsert`: Se ejecuta despu茅s de que una nueva entidad ha sido insertada en la base de datos.
- `@BeforeUpdate`: Se ejecuta antes de que una entidad existente sea actualizada en la base de datos.
- `@AfterUpdate`: Se ejecuta despu茅s de que una entidad existente ha sido actualizada en la base de datos.
- `@BeforeRemove`: Se ejecuta antes de que una entidad sea eliminada de la base de datos.
- `@AfterRemove`: Se ejecuta despu茅s de que una entidad ha sido eliminada de la base de datos.
- `@AfterLoad`: Se ejecuta despu茅s de que una entidad ha sido cargada desde la base de datos.
- `@BeforeRecover`: Se ejecuta antes de que una entidad soft-deleted sea recuperada.
- `@AfterRecover`: Se ejecuta despu茅s de que una entidad soft-deleted ha sido recuperada.

### 3. Diferencia ente Subscribers y Entity Listeners

En TypeORM, tanto los Subscribers como los Entity Listeners son mecanismos que permiten interceptar eventos espec铆ficos del ciclo de vida de las entidades (como antes de insertar, despu茅s de actualizar, etc.). Sin embargo, hay diferencias clave en su uso y en c贸mo se configuran.

### ★Subscribers

- Los Subscribers son clases separadas que escuchan eventos de m煤ltiples entidades.
- Un Subscriber puede estar asociado a una o varias entidades y manejar sus eventos.
- Los Subscribers permiten una mayor separaci贸n de las preocupaciones, ya que la l贸gica de los eventos se mantiene fuera de la entidad.
  **Caracter铆sticas:**
- **Definici贸n Externa**: Se definen en una clase separada.
- **Decorador `@EventSubscriber`**: Se utiliza para marcar la clase como un suscriptor.
- **M茅todos Espec铆ficos de Eventos**: Implementan m茅todos como `beforeInsert`, `afterUpdate`, etc., que se ejecutan en respuesta a eventos espec铆ficos.
- **Abarca M煤ltiples Entidades**: Un Subscriber puede estar asociado a m煤ltiples entidades, no solo a una.

### ★Entity Listeners

- Los Entity Listeners son m茅todos especiales dentro de una entidad que se ejecutan autom谩ticamente en respuesta a eventos espec铆ficos del ciclo de vida de esa entidad. Estos m茅todos se definen directamente dentro de la clase de la entidad y utilizan decoradores para indicar en qu茅 punto del ciclo de vida deben ejecutarse (antes de insertar, despu茅s de actualizar, etc.).
  **Caracter铆sticas:**
- **Definici贸n Interna**: Se definen dentro de la propia entidad.
- **Decoradores Espec铆ficos**: Utilizan decoradores como `@BeforeInsert`, `@AfterUpdate`, etc., para definir en qu茅 momento del ciclo de vida de la entidad se deben ejecutar.
- **Espec铆ficos de la Entidad**: Solo afectan a la entidad en la que est谩n definidos.
